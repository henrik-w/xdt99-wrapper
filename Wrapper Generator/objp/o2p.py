import os.path as op
import inspect
import datetime

from util import instance
from base import (PYTYPE2SPEC, tmpl_replace, copy_objp_unit, ArgSpec, MethodSpec, ClassSpec,
    get_objc_signature)

TEMPLATE_COPYRIGHT = """//
//  %%filename%%
//  XDTools99
//
//  This file was automatically created by XDT-Wrapper-Tools on %%creationdate%%.
//  CAUTION: DO NOT EDIT THIS FILE! CHANGES WILL BE OVERWRITTEN.
//
//  XDTools99.framework a collection of Objective-C wrapper for xdt99
//  Copyright Â© 2016-2019 Henrik Wedekind (aka hackmac). All rights reserved.
//
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as
//  published by the Free Software Foundation; either version 2.1 of the
//  License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this program; if not, see <http://www.gnu.org/licenses/>
//
"""

TEMPLATE_HEADER = """
#import <Cocoa/Cocoa.h>
#import <Python.h>

%%imports%%


@interface %%classname%% : NSObject %%protocols%%
{
    PyObject *_py;
}

- (PyObject *)pyRef;

%%methods%%

@end
"""

TEMPLATE_HEADER_INHERITED = """
#import <Cocoa/Cocoa.h>
#import <Python.h>

%%imports%%


@interface %%classname%% : %%superclass%% %%protocols%%

%%methods%%

@end
"""

TEMPLATE_UNIT = """
#import "%%classname%%.h"
#import "ObjP.h"


@implementation %%classname%%

- (void)dealloc
{
    OBJP_LOCKGIL;
    Py_DECREF(_py);
    OBJP_UNLOCKGIL;
    [super dealloc];
}


- (PyObject *)pyRef
{
    return _py;
}


%%methods%%

@end
"""

TEMPLATE_UNIT_INHERITED = """
#import "%%classname%%.h"
#import "ObjP.h"


@implementation %%classname%%

%%methods%%

@end
"""

TEMPLATE_INIT_METHOD = """
- %%signature%%
{
    self = [super init];
    if (nil == self) {
        return nil;
    }

    OBJP_LOCKGIL;
    PyObject *pFunc = ObjP_findPythonClass(@"%%classname%%", nil);
    %%funccall%%
    _py = pResult;
    OBJP_UNLOCKGIL;

    return self;
}

"""

TEMPLATE_CLASS_METHOD = """
+ %%signature%%
{
    // TODO: Implement automatic generation of class methods (like convinion methods for creating new objects).
    %%returncode%%
}

"""

TEMPLATE_METHOD = """
- %%signature%%
{
    OBJP_LOCKGIL;
    PyObject *pFunc = PyObject_GetAttrString(_py, "%%pyname%%");
    OBJP_ERRCHECK(pFunc);
    %%funccall%%
    %%returncode%%
}

"""

TEMPLATE_FUNCCALL = """
%%argscreate%%
    PyObject *pResult = PyObject_CallFunctionObjArgs(pFunc, %%argslist%%);
%%argsdecref%%
    OBJP_ERRCHECK(pResult);
    Py_DECREF(pFunc);
"""

TEMPLATE_RETURN_VOID = """
    Py_DECREF(pResult);
    OBJP_UNLOCKGIL;
"""

TEMPLATE_RETURN = """
    %%type%% result = %%pyconversion%%;
    Py_DECREF(pResult);
    OBJP_UNLOCKGIL;
    return result;
"""

classPrefix = 'XDT'

def camelcase(s):
    elems = s.split('_')
    elems = [elems[0]] + [e.title() for e in elems[1:]]
    return ''.join(elems)

def internalize_argspec(name, argspec, is_inherited):
    # take argspec from the inspect module and returns MethodSpec
    args = argspec.args[1:] # remove self
    annotations = argspec.annotations
    argspecs = []
    for argName in args:
        # generic type (object) for any argument which does not have an annotation
        annotation = annotations[argName] if argName in annotations else object
        typeSpec = PYTYPE2SPEC[annotation]
        argspecs.append(ArgSpec(argName, typeSpec))
    if name == '__init__':
        # generate objcname from args and always have an object return type
        returntype = PYTYPE2SPEC[instance]
        if argspecs:
            argnames = [camelcase(arg.argname) for arg in argspecs]
            argnames[0] = argnames[0].title()
            objcname = 'initWith' + ':'.join(argnames) + ':'
        else:
            objcname = 'init'
    else:
        returntype = PYTYPE2SPEC[annotations['return']] if 'return' in annotations else None
        # TODO: hier den Funktionsnamen der Objective-C Nomenklatur anpassen, falls es mehr args gibt als '_' im Python-Namen (oder diesen automatismus abschalten)
        objcname = name.replace('_', ':')
    return MethodSpec(name, objcname, argspecs, returntype, is_inherited)

def get_arg_c_code(argspecs):
    result = []
    for arg in argspecs:
        result.append(arg.typespec.o2p_code % arg.argname)
    result.append('NULL') # We have to add a NULL item in va_args in PyObject_CallMethodObjArgs
    return ', '.join(result)

def get_objc_method_code(clsspec, methodspec):
    signature = get_objc_signature(methodspec)
    argspecs = methodspec.argspecs
    fmt = '    PyObject *p%s = %s;'
    tmpl_argscreate = '\n'.join([fmt % (arg.argname, arg.typespec.o2p_code % arg.argname) for arg in argspecs])
    tmpl_argslist = ', '.join(['p' + arg.argname for arg in argspecs] + ['NULL'])
    fmt = '    Py_DECREF(p%s);'
    tmpl_argsdecref = '\n'.join([fmt % (arg.argname) for arg in argspecs])
    tmpl_funccall = tmpl_replace(TEMPLATE_FUNCCALL, argscreate=tmpl_argscreate,
        argslist=tmpl_argslist, argsdecref=tmpl_argsdecref)
    if methodspec.returntype is not None:
        ts = methodspec.returntype
        tmpl_pyconversion = ts.p2o_code % 'pResult'
        returncode = tmpl_replace(TEMPLATE_RETURN, type=ts.objctype, pyconversion=tmpl_pyconversion)
    else:
        returncode = TEMPLATE_RETURN_VOID
    if methodspec.pyname == '__init__':
        code = tmpl_replace(TEMPLATE_INIT_METHOD, signature=signature, classname=clsspec.clsname,
            funccall=tmpl_funccall)
    else:
        code = tmpl_replace(TEMPLATE_METHOD, signature=signature, pyname=methodspec.pyname,
            funccall=tmpl_funccall, returncode=returncode)
    sig = '- %s;' % signature
    return (code, sig)

def spec_from_python_class(class_):
    methods = inspect.getmembers(class_, inspect.isfunction)
    methodspecs = []
    for name, method in methods:
        if getattr(method, 'dontwrap', False):
            continue
        argspec = inspect.getfullargspec(method)
        is_inherited = name not in class_.__dict__
        try:
            if hasattr(method, 'objcname'):
                name = method.objcname
            methodspec = internalize_argspec(name, argspec, is_inherited)
            methodspecs.append(methodspec)
        except AssertionError:
            print("Warning: Couldn't generate spec for %s" % name)
            continue
    if not any(ms.pyname == '__init__' for ms in methodspecs):
        # Always create a default init method.
        methodspecs.insert(0, MethodSpec('__init__', 'init', [], PYTYPE2SPEC[instance], True))
    follow_protocols = getattr(class_, 'FOLLOW_PROTOCOLS', [])
    superclass = class_.__bases__[0].__name__ if class_.__bases__[0] is not object else None
    return ClassSpec(class_.__name__, superclass, methodspecs, True, follow_protocols)

def generate_objc_code(class_, destfolder, inherit=False):
    clsspec = spec_from_python_class(class_)
    clsname = classPrefix + clsspec.clsname
    method_code = []
    method_sigs = []
    for methodspec in clsspec.methodspecs:
        if inherit and methodspec.is_inherited and methodspec.pyname != '__init__':
            continue
        try:
            code, sig = get_objc_method_code(clsspec, methodspec)
        except AssertionError:
            print("Warning: Couldn't generate code for %s" % methodspec.pyname)
            continue
        method_code.append(code)
        method_sigs.append(sig)
    if clsspec.follow_protocols:
        tmpl_imports = ('#import "%s.h"' % imp for imp in clsspec.follow_protocols)
        tmpl_protocols = '<%s>' % ', '.join(clsspec.follow_protocols)
    else:
        tmpl_imports = []
        tmpl_protocols = ''
    if inherit and clsspec.superclass:
        tmpl_superclass = clsspec.superclass
        tmpl_imports.append('#import "%s.h"' % clsspec.superclass)
        header = tmpl_replace(TEMPLATE_HEADER_INHERITED, classname=clsname, methods='\n'.join(method_sigs),
                              imports='\n'.join(tmpl_imports), protocols=tmpl_protocols,
                              superclass=tmpl_superclass
                              )
        implementation = tmpl_replace(TEMPLATE_UNIT_INHERITED, classname=clsname, methods=''.join(method_code))
    else:
        header = tmpl_replace(TEMPLATE_HEADER, classname=clsname, methods='\n'.join(method_sigs),
                              imports='\n'.join(tmpl_imports), protocols=tmpl_protocols
                              )
        implementation = tmpl_replace(TEMPLATE_UNIT, classname=clsname, methods=''.join(method_code))
    copy_objp_unit(destfolder)
    creationDate = datetime.date.today().strftime('%x')

    fileName = '%s.h' % clsname
    with open(op.join(destfolder, fileName), 'wt') as fp:
        fp.write(tmpl_replace(TEMPLATE_COPYRIGHT, creationdate=creationDate, filename=fileName))
        fp.write(header)
    fileName = '%s.m' % clsname
    with open(op.join(destfolder, fileName), 'wt') as fp:
        fp.write(tmpl_replace(TEMPLATE_COPYRIGHT, creationdate=creationDate, filename=fileName))
        fp.write(implementation)
